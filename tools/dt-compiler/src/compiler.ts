import * as fs from 'fs';
import * as path from 'path';
import * as crypto from 'crypto';

// --- Types ---
type DecisionType = 'APPROVED' | 'HOLD' | 'STOP';

interface ParsedRule {
    conditions: Record<string, any>;
    action: DecisionType;
    reasonCode: string;
    sourceTable: string;
}

interface CompileOutput {
    version: string;
    compiledAt: string;
    hash: string;
    rules: ParsedRule[];
}

function walkSync(dir: string, filelist: string[] = []): string[] {
    const files = fs.readdirSync(dir);
    for (const file of files) {
        const filepath = path.join(dir, file);
        const stat = fs.statSync(filepath);
        if (stat.isDirectory()) {
            filelist = walkSync(filepath, filelist);
        } else if (file.endsWith('.md')) {
            filelist.push(filepath);
        }
    }
    return filelist;
}

// --- Hardcoded Baseline Parser (Deterministic) ---
function parseTable(content: string, filename: string): ParsedRule[] {
    const rules: ParsedRule[] = [];
    const lines = content.split('\n');
    let inTable = false;
    let headers: string[] = [];

    for (const line of lines) {
        if (line.trim().startsWith('|')) {
            const columns = line.split('|').map(c => c.trim()).filter(c => c.length > 0);

            if (!inTable) {
                // First pipe encounter is the header row
                headers = columns;
                inTable = true;
                continue;
            }

            // Skip the alignment row (e.g., |---|---|)
            if (columns[0].startsWith('---')) continue;

            // Enforce structure: [Conditions...], Decision, ReasonCode
            if (columns.length === headers.length) {
                const rule: ParsedRule = {
                    conditions: {},
                    action: 'HOLD',
                    reasonCode: 'UNPARSEABLE',
                    sourceTable: filename
                };

                for (let i = 0; i < headers.length; i++) {
                    const headerText = headers[i].toLowerCase();
                    if (headerText === 'decision') {
                        rule.action = columns[i].toUpperCase() as DecisionType;
                    } else if (headerText === 'reasoncode' || headerText === 'reason') {
                        rule.reasonCode = columns[i];
                    } else {
                        // All other columns are treated as required conditions.
                        // "ANY" implies no condition necessary for that key.
                        if (columns[i].toUpperCase() !== 'ANY' && columns[i] !== '*') {
                            rule.conditions[headers[i]] = columns[i];
                        }
                    }
                }
                rules.push(rule);
            }
        }
    }
    return rules;
}

function generateEnums(rules: ParsedRule[], outputDir: string) {
    const reasonCodes = new Set<string>();
    rules.forEach(r => reasonCodes.add(r.reasonCode));

    const enumContent = `// AUTOGENERATED VIA DT-COMPILER - DO NOT EDIT MANUALLY\n\nexport enum HoldStopReason {\n${Array.from(reasonCodes).sort().map(code => `    ${code} = "${code}"`).join(',\n')}\n}\n`;

    fs.writeFileSync(path.join(outputDir, 'enums.generated.ts'), enumContent);
}

// --- Compiler Execution ---
function executeGlobalCompile() {
    console.log('[DT Compiler] Initializing deterministic compilation...');

    const inputPathDir = path.resolve(__dirname, '../../../chapters/brain/decision_tables');
    const outputPathDir = path.resolve(__dirname, '../compiled');

    if (!fs.existsSync(inputPathDir)) {
        console.warn(`[DT Compiler] Input directory missing: ${inputPathDir}. Creating empty dir.`);
        fs.mkdirSync(inputPathDir, { recursive: true });
    }

    if (!fs.existsSync(outputPathDir)) {
        fs.mkdirSync(outputPathDir, { recursive: true });
    }

    const files = walkSync(inputPathDir).sort();

    const compiledGraph: CompileOutput = {
        version: "v1.0.0",
        compiledAt: new Date().toISOString(),
        hash: "",
        rules: []
    };

    for (const filePath of files) {
        const file = path.basename(filePath);
        const content = fs.readFileSync(filePath, 'utf8');
        console.log(`[DT Compiler] Parsing: ${file}`);
        const extractedRules = parseTable(content, file);
        compiledGraph.rules.push(...extractedRules);
    }

    // Stable Hash Generation for Determinism
    const hashPayload = JSON.stringify(compiledGraph.rules);
    compiledGraph.hash = crypto.createHash('sha256').update(hashPayload).digest('hex');

    const outputPath = path.join(outputPathDir, 'decision_graph.json');
    fs.writeFileSync(outputPath, JSON.stringify(compiledGraph, null, 2));

    // Generate Enums
    generateEnums(compiledGraph.rules, outputPathDir);

    console.log(`[DT Compiler] Compilation Success. [${compiledGraph.rules.length}] Deterministic rules locked.`);
    console.log(`[DT Compiler] Hash: ${compiledGraph.hash}`);
    console.log(`[DT Compiler] Emitted artifact to: ${outputPath}`);
}

executeGlobalCompile();
